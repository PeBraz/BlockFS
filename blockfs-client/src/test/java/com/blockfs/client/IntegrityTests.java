package com.blockfs.client;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.File;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;



public class IntegrityTests
{

    private final String BLOCK_DIR = "../data";

    private final IBlockClient client = new BlockClient();


    private final Runtime rt = Runtime.getRuntime();

    @Before
    public void setUp() {
        File path = new File(BLOCK_DIR);
        if (path.exists())
            for (File f : path.listFiles())
                f.delete();
        else
            path.mkdir();
    }

    @After
    public void tearDown() {
        File path = new File(BLOCK_DIR);
        for (File f : path.listFiles())
            f.delete();
    }

    /**
     *  Tests that a wrong hash generated by the server is not accepted
     *  server:-WPHASH
     */

    @Test
    public void testWriteDataBlockInvalid() {

        try {
            client.FS_init(BLOCK_DIR + "/joao", "1234");
        } catch (WrongPasswordException | ClientProblemException e) {

            fail();
        }
        try {
            //write will perform 1 getPKB() after finding a empty list it will put a new data block
            //the client will check a wrong hash on the put_h
            client.FS_write(0, 10, new byte[10]);
        } catch (IBlockClient.UninitializedFSException | ServerRespondedErrorException | ClientProblemException  e) {
            fail();
        } catch (IBlockServerRequests.IntegrityException e) {
            assertTrue(true);
            return;
        }
        fail();
    }
    /**
     *  Tests that the contents of a data block received were changed, when server sends contents back to client
     * server:-WGDBHASH
     */

    @Test
    public void testReadDataBlockInvalid() {

        String pkHash = "";
        try {
            pkHash = client.FS_init(BLOCK_DIR + "/joao", "1234");
        } catch (WrongPasswordException | ClientProblemException e) {
            fail();
        }
        try {
            //write will perform 1 getPKB() after finding a empty list  (that shouldnt be verified)
            //the client will put a new data block
            //and put a new key block
            client.FS_write(0, 10, new byte[10]);
        } catch (IBlockClient.UninitializedFSException | IBlockServerRequests.IntegrityException | ServerRespondedErrorException | ClientProblemException e) {
            fail();
        }
        byte[] buffer = new byte[10];
        try {
            //the client will read a invalid block
            client.FS_read(pkHash, 0, 10, buffer);
        }catch (IBlockServerRequests.IntegrityException e) {
            assertTrue(true);
            return;
        } catch (ServerRespondedErrorException e) {
            fail();
        }

        fail();

    }
    /**
     *  Tests that the public key on a public key block was changed
     *  server: -WGPKHASH
     */

    @Test
    public void testReadPKBlockInvalid() {


        String pkHash = "";
        try {
            pkHash = client.FS_init(BLOCK_DIR + "/joao", "1234");
        } catch (WrongPasswordException | ClientProblemException e) {
            fail();
        }
        try {
            //write will perform 1 getPKB() after finding a empty list  (that shouldnt be verified)
            //the client will put a new data block
            //and put a new key block
            client.FS_write(0, 10, new byte[10]);
        } catch (IBlockClient.UninitializedFSException | IBlockServerRequests.IntegrityException | ServerRespondedErrorException | ClientProblemException e) {
            fail();
        }
        byte[] buffer = new byte[10];
        try {
            //the client will read pk block with the wrong key
            client.FS_read(pkHash, 0, 10, buffer);
        }catch (IBlockServerRequests.IntegrityException e) {
            assertTrue(true);
            return;
        } catch (ServerRespondedErrorException e) {
            fail();
        }

        fail("Public key returned was invalid, but it wasn't checked");

    }

    /**
     * Tests that the signature was incorrect and server doesn't accept content (400)
     * server: -WCSIG
     */

    @Test
    public void testReadPKBInvalidSignatureAtServer() {

        try {
            client.FS_init(BLOCK_DIR + "/joao", "1234");
        } catch (WrongPasswordException | ClientProblemException e) {
            fail();
        }
        try {
            //write will perform 1 getPKB() after finding a empty list it will put a new data block
            //after the client ends writing the blocks it will update the pk block and receive a 400 from the server
            client.FS_write(0, 10, new byte[10]);
        } catch (IBlockClient.UninitializedFSException | ClientProblemException  e) {
            fail();
        } catch (IBlockServerRequests.IntegrityException | ServerRespondedErrorException e) {
            assertTrue(true);
            return;
        }
        fail();
    }

    /**
     * Tests that file signature returned to the client is incorrect
     * server: -WSSIG
     */

    @Test
    public void testReadPKBInvalidSignatureAtClient() {

        String pkHash = "";
        try {
            pkHash = client.FS_init(BLOCK_DIR + "/joao", "1234");
        } catch (WrongPasswordException | ClientProblemException e) {
            fail();
        }
        try {
            //write will perform 1 getPKB() after finding a empty list it will put a new data block
            //after the client ends writing the blocks it will update the pk block
            // and check that the signature doesn't correspond to the data
            byte[] buffer = new byte[10];
            client.FS_write(0, 10, new byte[10]);
            client.FS_read(pkHash, 0, 10, buffer);
        } catch (IBlockClient.UninitializedFSException | ServerRespondedErrorException | ClientProblemException  e) {
            fail();
        } catch (IBlockServerRequests.IntegrityException  e) {
            assertTrue(true);
            return;
        }
        fail("Signature was incorrect, but wasn't caught");
    }


}
